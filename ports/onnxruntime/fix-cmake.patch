diff --git a/cmake/CMakeLists.txt b/cmake/CMakeLists.txt
index a5d28fb..ee07ec1 100644
--- a/cmake/CMakeLists.txt
+++ b/cmake/CMakeLists.txt
@@ -14,6 +14,7 @@ cmake_policy(SET CMP0104 OLD)
 
 # Project
 project(onnxruntime C CXX ASM)
+include(GNUInstallDirs)
 
 # Needed for Java
 set(CMAKE_C_STANDARD 99)
@@ -318,10 +319,10 @@ endif()
 
 if (APPLE)
     if (NOT CMAKE_OSX_ARCHITECTURES)
-        message("Building ONNX Runtime for ${CMAKE_HOST_SYSTEM_PROCESSOR}")
+        message(STATUS "Building ONNX Runtime for ${CMAKE_HOST_SYSTEM_PROCESSOR}")
     endif()
 elseif (NOT WIN32 AND NOT APPLE)
-    message("Building ONNX Runtime for ${CMAKE_SYSTEM_PROCESSOR}")
+    message(STATUS "Building ONNX Runtime for ${CMAKE_SYSTEM_PROCESSOR}")
 endif()
 
 # Single output director for all binaries
@@ -463,11 +464,11 @@ file (STRINGS "${REPO_ROOT}/VERSION_NUMBER" ORT_VERSION)
 find_package(Threads)
 find_package(Patch)
 if(Patch_FOUND)
-  message("Patch found: ${Patch_EXECUTABLE}")
+  message(STATUS "Patch found: ${Patch_EXECUTABLE}")
 endif()
 
 if (CMAKE_CROSSCOMPILING)
-  message("Doing crosscompiling")
+  message(STATUS "Doing crosscompiling")
 endif()
 
 #Need python to generate def file
@@ -489,6 +490,7 @@ get_filename_component(ORTTRAINING_ROOT "${ORTTRAINING_ROOT}" ABSOLUTE)
 get_filename_component(REPO_ROOT "${REPO_ROOT}" ABSOLUTE)
 set(ONNXRUNTIME_INCLUDE_DIR ${REPO_ROOT}/include/onnxruntime)
 
+list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/external)
 include(external/onnxruntime_external_deps.cmake)
 
 set(ORT_WARNING_FLAGS)
diff --git a/cmake/adjust_global_compile_flags.cmake b/cmake/adjust_global_compile_flags.cmake
index e072363..dfc760d 100644
--- a/cmake/adjust_global_compile_flags.cmake
+++ b/cmake/adjust_global_compile_flags.cmake
@@ -276,10 +276,10 @@ if (MSVC)
   if (NOT GDK_PLATFORM)
     add_compile_definitions(WINAPI_FAMILY=100) # Desktop app
     if (onnxruntime_USE_WINML OR NOT CMAKE_CXX_STANDARD_LIBRARIES MATCHES kernel32.lib)
-        message("Building ONNX Runtime for Windows 8 and newer")
+        message(STATUS "Building ONNX Runtime for Windows 8 and newer")
         add_compile_definitions(WINVER=0x0602 _WIN32_WINNT=0x0602 NTDDI_VERSION=0x06020000)  # Support Windows 8 and newer
     else()
-        message("Building ONNX Runtime for Windows 7 and newer")
+        message(STATUS "Building ONNX Runtime for Windows 7 and newer")
         # For people who build ONNX Runtime from source, the result binary may still support Windows 7
         # Windows 7 doesn't have OneCore. So if CMAKE_CXX_STANDARD_LIBRARIES is for OneCore, the build won't come here
         add_compile_definitions(WINVER=0x0601 _WIN32_WINNT=0x0601 NTDDI_VERSION=0x06010000)  # Support Windows 7 and newer
diff --git a/cmake/external/onnxruntime_external_deps.cmake b/cmake/external/onnxruntime_external_deps.cmake
index 0c41945..593912e 100644
--- a/cmake/external/onnxruntime_external_deps.cmake
+++ b/cmake/external/onnxruntime_external_deps.cmake
@@ -1,4 +1,4 @@
-message("Loading Dependencies URLs ...")
+message(STATUS "Loading Dependencies URLs ...")
 
 include(external/helper_functions.cmake)
 
@@ -17,19 +17,13 @@ foreach(ONNXRUNTIME_DEP IN LISTS ONNXRUNTIME_DEPS_LIST)
   endif()
 endforeach()
 
-message("Loading Dependencies ...")
+message(STATUS "Loading Dependencies ...")
 # ABSL should be included before protobuf because protobuf may use absl
 if(NOT onnxruntime_DISABLE_ABSEIL)
   include(external/abseil-cpp.cmake)
 endif()
 
-set(RE2_BUILD_TESTING OFF CACHE BOOL "" FORCE)
-FetchContent_Declare(
-    re2
-    URL ${DEP_URL_re2}
-    URL_HASH SHA1=${DEP_SHA1_re2}
-    FIND_PACKAGE_ARGS NAMES re2
-)
+find_package(re2 CONFIG REQUIRED) # re2::re2
 
 if (onnxruntime_BUILD_UNIT_TESTS)
   # WebAssembly threading support in Node.js is still an experimental feature and
@@ -43,379 +37,104 @@ if (onnxruntime_BUILD_UNIT_TESTS)
     set(GTEST_HAS_ABSL OFF CACHE BOOL "" FORCE)
   endif()
   # gtest and gmock
-  FetchContent_Declare(
-    googletest
-    URL ${DEP_URL_googletest}
-    FIND_PACKAGE_ARGS NAMES GTest
-    URL_HASH SHA1=${DEP_SHA1_googletest}
-  )
+  find_package(GTest CONFIG REQUIRED)
+  # GTest::gtest GTest::gtest_main
+  # GTest::gmock GTest::gmock_main
 endif()
 
 if (onnxruntime_BUILD_BENCHMARKS)
-  # We will not need to test benchmark lib itself.
-  set(BENCHMARK_ENABLE_TESTING OFF CACHE BOOL "Disable benchmark testing as we don't need it.")
-  # We will not need to install benchmark since we link it statically.
-  set(BENCHMARK_ENABLE_INSTALL OFF CACHE BOOL "Disable benchmark install to avoid overwriting vendor install.")
-
-  FetchContent_Declare(
-    google_benchmark
-    URL ${DEP_URL_google_benchmark}
-    URL_HASH SHA1=${DEP_SHA1_google_benchmark}
-  )
+  find_package(benchmark CONFIG REQUIRED) # benchmark::benchmark benchmark::benchmark_main
 endif()
 
 if (NOT WIN32)
-    FetchContent_Declare(
-    google_nsync
-    URL ${DEP_URL_google_nsync}
-    URL_HASH SHA1=${DEP_SHA1_google_nsync}
-    FIND_PACKAGE_ARGS NAMES nsync
-    )
+  find_package(unofficial-nsync CONFIG REQUIRED) # unofficial::nsync::nsync unofficial::nsync::nsync_cpp
 endif()
-list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/external)
-
-FetchContent_Declare(
-      mimalloc
-      URL ${DEP_URL_mimalloc}
-      URL_HASH SHA1=${DEP_SHA1_mimalloc}
-)
-
-
 
 # Flatbuffers
-# We do not need to build flatc for iOS or Android Cross Compile
-if (CMAKE_SYSTEM_NAME STREQUAL "iOS" OR CMAKE_SYSTEM_NAME STREQUAL "Android" OR onnxruntime_BUILD_WEBASSEMBLY)
-  set(FLATBUFFERS_BUILD_FLATC OFF CACHE BOOL "FLATBUFFERS_BUILD_FLATC" FORCE)
-endif()
-set(FLATBUFFERS_BUILD_TESTS OFF CACHE BOOL "FLATBUFFERS_BUILD_TESTS" FORCE)
-set(FLATBUFFERS_INSTALL OFF CACHE BOOL "FLATBUFFERS_INSTALL" FORCE)
-set(FLATBUFFERS_BUILD_FLATHASH OFF CACHE BOOL "FLATBUFFERS_BUILD_FLATHASH" FORCE)
-set(FLATBUFFERS_BUILD_FLATLIB ON CACHE BOOL "FLATBUFFERS_BUILD_FLATLIB" FORCE)
-
 #flatbuffers 1.11.0 does not have flatbuffers::IsOutRange, therefore we require 1.12.0+
-FetchContent_Declare(
-    flatbuffers
-    URL ${DEP_URL_flatbuffers}
-    URL_HASH SHA1=${DEP_SHA1_flatbuffers}
-    FIND_PACKAGE_ARGS 1.12.0...<2.0.0 NAMES Flatbuffers
-)
-
-#Here we support two build mode:
-#1. if ONNX_CUSTOM_PROTOC_EXECUTABLE is set, build Protobuf from source, except protoc.exe. This mode is mainly
-#   for cross-compiling
-#2. if ONNX_CUSTOM_PROTOC_EXECUTABLE is not set, Compile everything(including protoc) from source code.
-if(Patch_FOUND)
-  set(ONNXRUNTIME_PROTOBUF_PATCH_COMMAND ${Patch_EXECUTABLE} --binary --ignore-whitespace -p1 < ${PROJECT_SOURCE_DIR}/patches/protobuf/protobuf_cmake.patch)
-else()
- set(ONNXRUNTIME_PROTOBUF_PATCH_COMMAND "")
-endif()
-FetchContent_Declare(
-  Protobuf
-  URL ${DEP_URL_protobuf}
-  URL_HASH SHA1=${DEP_SHA1_protobuf}
-  SOURCE_SUBDIR  cmake
-  PATCH_COMMAND ${ONNXRUNTIME_PROTOBUF_PATCH_COMMAND}
-  FIND_PACKAGE_ARGS 3.20.2 NAMES Protobuf
-)
-set(protobuf_BUILD_TESTS OFF CACHE BOOL "Build protobuf tests" FORCE)
-if (CMAKE_SYSTEM_NAME STREQUAL "Android")
-  set(protobuf_BUILD_PROTOC_BINARIES OFF CACHE BOOL "Build protobuf tests" FORCE)
-  set(protobuf_WITH_ZLIB OFF CACHE BOOL "Build with zlib support" FORCE)
-endif()
-if (onnxruntime_DISABLE_RTTI)
-  set(protobuf_DISABLE_RTTI ON CACHE BOOL "Remove runtime type information in the binaries" FORCE)
-endif()
-
-include(protobuf_function)
-#protobuf end
-
-set(ENABLE_DATE_TESTING  OFF CACHE BOOL "" FORCE)
-set(USE_SYSTEM_TZ_DB  ON CACHE BOOL "" FORCE)
-
-FetchContent_Declare(
-      date
-      URL ${DEP_URL_date}
-      URL_HASH SHA1=${DEP_SHA1_date}
-    )
-onnxruntime_fetchcontent_makeavailable(date)
-
+find_package(flatbuffers 1.12.0 CONFIG REQUIRED) # flatbuffers::flatbuffers
 
+find_package(date CONFIG REQUIRED) # date::date date::date-tz
 
-FetchContent_Declare(
-  mp11
-  URL ${DEP_URL_mp11}
-  URL_HASH SHA1=${DEP_SHA1_mp11}
-)
-
-set(JSON_BuildTests OFF CACHE INTERNAL "")
-set(JSON_Install OFF CACHE INTERNAL "")
-set(JSON_BuildTests OFF CACHE INTERNAL "")
-set(JSON_Install OFF CACHE INTERNAL "")
+find_path(BOOST_INCLUDEDIR "boost/mp11.hpp" REQUIRED)
+find_package(Boost REQUIRED) # Boost::headers instead of Boost::mp11
 
-FetchContent_Declare(
-    nlohmann_json
-    URL ${DEP_URL_json}
-    URL_HASH SHA1=${DEP_SHA1_json}
-    FIND_PACKAGE_ARGS 3.10 NAMES nlohmann_json
-)
+find_package(nlohmann_json CONFIG REQUIRED) # nlohmann_json::nlohmann_json
 
 #TODO: include clog first
 if (onnxruntime_ENABLE_CPUINFO)
-  # Adding pytorch CPU info library
-  # TODO!! need a better way to find out the supported architectures
-  list(LENGTH CMAKE_OSX_ARCHITECTURES CMAKE_OSX_ARCHITECTURES_LEN)
-  if (APPLE)
-    if (CMAKE_OSX_ARCHITECTURES_LEN LESS_EQUAL 1)
-      set(CPUINFO_SUPPORTED TRUE)
-    elseif (onnxruntime_BUILD_APPLE_FRAMEWORK)
-      # We stitch multiple static libraries together when onnxruntime_BUILD_APPLE_FRAMEWORK is true,
-      # but that would not work for universal static libraries
-      message(FATAL_ERROR "universal binary is not supported for apple framework")
-    endif()
-  else()
-    # if xnnpack is enabled in a wasm build it needs clog from cpuinfo, but we won't internally use cpuinfo
-    # so we don't set CPUINFO_SUPPORTED in the CXX flags below.
-    if (onnxruntime_BUILD_WEBASSEMBLY AND NOT onnxruntime_USE_XNNPACK)
-      set(CPUINFO_SUPPORTED FALSE)
-    else()
-      set(CPUINFO_SUPPORTED TRUE)
-    endif()
-    if (WIN32)
-      # Exclude Windows ARM build and Windows Store
-      if (${onnxruntime_target_platform} MATCHES "^(ARM.*|arm.*)$" )
-        message(WARNING "Cpuinfo not included for compilation problems with Windows ARM.")
-        set(CPUINFO_SUPPORTED FALSE)
-      elseif (WIN32 AND NOT CMAKE_CXX_STANDARD_LIBRARIES MATCHES kernel32.lib)
-        message(WARNING "Cpuinfo not included non-Desktop builds")
-        set(CPUINFO_SUPPORTED FALSE)
-      endif()
-    elseif (NOT ${onnxruntime_target_platform} MATCHES "^(i[3-6]86|AMD64|x86(_64)?|armv[5-8].*|aarch64|arm64)$")
-      message(WARNING
-        "Target processor architecture \"${onnxruntime_target_platform}\" is not supported in cpuinfo. "
-        "cpuinfo not included."
-      )
-      set(CPUINFO_SUPPORTED FALSE)
-    endif()
-  endif()
+  find_package(cpuinfo CONFIG REQUIRED) # cpuinfo::clog cpuinfo::cpuinfo
+  set(CPUINFO_SUPPORTED true)
 else()
   set(CPUINFO_SUPPORTED FALSE)
 endif()
 
-if (CPUINFO_SUPPORTED)
-  if (CMAKE_SYSTEM_NAME STREQUAL "iOS")
-    set(IOS ON CACHE INTERNAL "")
-    set(IOS_ARCH "${CMAKE_OSX_ARCHITECTURES}" CACHE INTERNAL "")
-  endif()
-
-  # if this is a wasm build with xnnpack (only type of wasm build where cpuinfo is involved)
-  # we do not use cpuinfo in ORT code, so don't define CPUINFO_SUPPORTED.
-  if (NOT onnxruntime_BUILD_WEBASSEMBLY)
-    string(APPEND CMAKE_CXX_FLAGS " -DCPUINFO_SUPPORTED")
-  endif()
-
+find_package(Microsoft.GSL CONFIG REQUIRED)
 
-  set(CPUINFO_BUILD_TOOLS OFF CACHE INTERNAL "")
-  set(CPUINFO_BUILD_UNIT_TESTS OFF CACHE INTERNAL "")
-  set(CPUINFO_BUILD_MOCK_TESTS OFF CACHE INTERNAL "")
-  set(CPUINFO_BUILD_BENCHMARKS OFF CACHE INTERNAL "")
-
-  FetchContent_Declare(
-    pytorch_cpuinfo
-    URL ${DEP_URL_pytorch_cpuinfo}
-    URL_HASH SHA1=${DEP_SHA1_pytorch_cpuinfo}
-    FIND_PACKAGE_ARGS NAMES cpuinfo
-  )
+find_path(SAFEINT_INCLUDE_DIRS "SafeInt.hpp" REQUIRED)
 
-endif()
-
-
-if (onnxruntime_BUILD_BENCHMARKS)
-  onnxruntime_fetchcontent_makeavailable(google_benchmark)
-endif()
-
-if (NOT WIN32)
-  #nsync tests failed on Mac Build
-  set(NSYNC_ENABLE_TESTS OFF CACHE BOOL "" FORCE)
-  onnxruntime_fetchcontent_makeavailable(google_nsync)
-  set(nsync_SOURCE_DIR ${google_nsync_SOURCE_DIR})
-endif()
-
-if(onnxruntime_USE_CUDA)
-  FetchContent_Declare(
-    GSL
-    URL ${DEP_URL_microsoft_gsl}
-    URL_HASH SHA1=${DEP_SHA1_microsoft_gsl}
-    PATCH_COMMAND ${Patch_EXECUTABLE} --binary --ignore-whitespace -p1 < ${PROJECT_SOURCE_DIR}/patches/gsl/1064.patch
-  )
-else()
-  FetchContent_Declare(
-    GSL
-    URL ${DEP_URL_microsoft_gsl}
-    URL_HASH SHA1=${DEP_SHA1_microsoft_gsl}
-    FIND_PACKAGE_ARGS 4.0 NAMES Microsoft.GSL
-  )
-endif()
-
-FetchContent_Declare(
-    safeint
-    URL ${DEP_URL_safeint}
-    URL_HASH SHA1=${DEP_SHA1_safeint}
-)
-
-# The next line will generate an error message "fatal: not a git repository", but it is ok. It is from flatbuffers
-onnxruntime_fetchcontent_makeavailable(Protobuf nlohmann_json mp11 re2 safeint GSL flatbuffers)
-if(NOT flatbuffers_FOUND)
-  if(NOT TARGET flatbuffers::flatbuffers)
-    add_library(flatbuffers::flatbuffers ALIAS flatbuffers)
-  endif()
-  if(TARGET flatc AND NOT TARGET flatbuffers::flatc)
-    add_executable(flatbuffers::flatc ALIAS flatc)
-  endif()
-  if (GDK_PLATFORM)
-    # cstdlib only defines std::getenv when _CRT_USE_WINAPI_FAMILY_DESKTOP_APP is defined, which
-    # is probably an oversight for GDK/Xbox builds (::getenv exists and works).
-    file(WRITE ${CMAKE_BINARY_DIR}/gdk_cstdlib_wrapper.h [[
-#pragma once
-#ifdef __cplusplus
-#include <cstdlib>
-namespace std { using ::getenv; }
-#endif
-]])
-    if(TARGET flatbuffers)
-      target_compile_options(flatbuffers PRIVATE /FI${CMAKE_BINARY_DIR}/gdk_cstdlib_wrapper.h)
-    endif()
-    if(TARGET flatc)
-      target_compile_options(flatc PRIVATE /FI${CMAKE_BINARY_DIR}/gdk_cstdlib_wrapper.h)
-    endif()
-  endif()
-endif()
-
-if (onnxruntime_BUILD_UNIT_TESTS)
-  onnxruntime_fetchcontent_makeavailable(googletest)
-endif()
+add_library(safeint_interface INTERFACE)
+target_include_directories(safeint_interface INTERFACE ${SAFEINT_INCLUDE_DIRS})
 
-if(Protobuf_FOUND)
-  message("Protobuf version: ${Protobuf_VERSION}")
-else()
-  # Adjust warning flags
-  if (TARGET libprotoc)
-    if (NOT MSVC)
-      target_compile_options(libprotoc PRIVATE "-w")
-    endif()
-  endif()
-  if (TARGET protoc)
-    add_executable(protobuf::protoc ALIAS protoc)
-    if (UNIX AND onnxruntime_ENABLE_LTO)
-      #https://github.com/protocolbuffers/protobuf/issues/5923
-      target_link_options(protoc PRIVATE "-Wl,--no-as-needed")
-    endif()
-    if (NOT MSVC)
-      target_compile_options(protoc PRIVATE "-w")
-    endif()
-    get_target_property(PROTOC_OSX_ARCH protoc OSX_ARCHITECTURES)
-    if (PROTOC_OSX_ARCH)
-      if (${CMAKE_HOST_SYSTEM_PROCESSOR} IN_LIST PROTOC_OSX_ARCH)
-        message("protoc can run")
-      else()
-        list(APPEND PROTOC_OSX_ARCH ${CMAKE_HOST_SYSTEM_PROCESSOR})
-        set_target_properties(protoc PROPERTIES OSX_ARCHITECTURES "${CMAKE_HOST_SYSTEM_PROCESSOR}")
-        set_target_properties(libprotoc PROPERTIES OSX_ARCHITECTURES "${PROTOC_OSX_ARCH}")
-        set_target_properties(libprotobuf PROPERTIES OSX_ARCHITECTURES "${PROTOC_OSX_ARCH}")
-      endif()
-    endif()
-   endif()
-  if (TARGET libprotobuf AND NOT MSVC)
-    target_compile_options(libprotobuf PRIVATE "-w")
-  endif()
-  if (TARGET libprotobuf-lite AND NOT MSVC)
-    target_compile_options(libprotobuf-lite PRIVATE "-w")
-  endif()
-endif()
+find_package(protobuf CONFIG REQUIRED) # protobuf::libprotobuf protobuf::libprotobuf-lite
+include(protobuf_function)
 if (onnxruntime_USE_FULL_PROTOBUF)
   set(PROTOBUF_LIB protobuf::libprotobuf)
 else()
   set(PROTOBUF_LIB protobuf::libprotobuf-lite)
 endif()
 
+find_package(Eigen3 CONFIG REQUIRED) # Eigen3::Eigen
+find_package(wil CONFIG REQUIRED) # WIL::WIL
 
-# ONNX
-if (NOT onnxruntime_USE_FULL_PROTOBUF)
-  set(ONNX_USE_LITE_PROTO ON CACHE BOOL "" FORCE)
-else()
-  set(ONNX_USE_LITE_PROTO OFF CACHE BOOL "" FORCE)
-endif()
-
-if(Patch_FOUND)
-  set(ONNXRUNTIME_ONNX_PATCH_COMMAND ${Patch_EXECUTABLE} --binary --ignore-whitespace -p1 < ${PROJECT_SOURCE_DIR}/patches/onnx/onnx.patch)
-else()
-  set(ONNXRUNTIME_ONNX_PATCH_COMMAND "")
-endif()
+find_path(ONNX_INCLUDE_DIR NAMES "onnx/common/version.h" REQUIRED)
+find_library(ONNX_LIBRARY NAMES onnx REQUIRED)
+find_library(ONNX_PROTO_LIBRARY NAMES onnx_proto REQUIRED)
 
-FetchContent_Declare(
-  onnx
-  URL ${DEP_URL_onnx}
-  URL_HASH SHA1=${DEP_SHA1_onnx}
-  PATCH_COMMAND ${ONNXRUNTIME_ONNX_PATCH_COMMAND}
+add_library(onnx STATIC IMPORTED GLOBAL)
+set_target_properties(onnx
+PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${ONNX_INCLUDE_DIR}"
+  INTERFACE_COMPILE_DEFINITIONS "ONNX_ML"
+  IMPORTED_IMPLIB "${ONNX_LIBRARY}"
+  IMPORTED_LOCATION "${ONNX_LIBRARY}"
 )
 
+add_library(onnx_proto STATIC IMPORTED GLOBAL)
+set_target_properties(onnx_proto
+PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${ONNX_INCLUDE_DIR}"
+  INTERFACE_COMPILE_DEFINITIONS "ONNX_ML"
+  IMPORTED_IMPLIB "${ONNX_PROTO_LIBRARY}"
+  IMPORTED_LOCATION "${ONNX_PROTO_LIBRARY}"
+)
 
-if (CPUINFO_SUPPORTED)
-  onnxruntime_fetchcontent_makeavailable(pytorch_cpuinfo)
-endif()
-
-
-
-include(eigen)
-include(wil)
-
-if (NOT onnxruntime_MINIMAL_BUILD)
-    onnxruntime_fetchcontent_makeavailable(onnx)
-else()
-  include(onnx_minimal)
-endif()
+add_compile_definitions(ONNX_NAMESPACE=onnx)
 
 set(GSL_TARGET "Microsoft.GSL::GSL")
 set(GSL_INCLUDE_DIR "$<TARGET_PROPERTY:${GSL_TARGET},INTERFACE_INCLUDE_DIRECTORIES>")
 
-add_library(safeint_interface INTERFACE)
-target_include_directories(safeint_interface INTERFACE ${safeint_SOURCE_DIR})
-
 # XNNPACK EP
 if (onnxruntime_USE_XNNPACK)
   if (onnxruntime_DISABLE_CONTRIB_OPS)
     message(FATAL_ERROR "XNNPACK EP requires the internal NHWC contrib ops to be available "
                          "but onnxruntime_DISABLE_CONTRIB_OPS is ON")
   endif()
-  include(xnnpack)
+  find_package(xnnpack CONFIG REQUIRED) # xnnpack
 endif()
 
 if (onnxruntime_USE_MIMALLOC)
-  add_definitions(-DUSE_MIMALLOC)
-
-  set(MI_OVERRIDE OFF CACHE BOOL "" FORCE)
-  set(MI_BUILD_TESTS OFF CACHE BOOL "" FORCE)
-  set(MI_DEBUG_FULL OFF CACHE BOOL "" FORCE)
-  set(MI_BUILD_SHARED OFF CACHE BOOL "" FORCE)
-  onnxruntime_fetchcontent_makeavailable(mimalloc)
+  find_package(mimalloc CONFIG REQUIRED) # mimalloc
+  add_compile_definitions(USE_MIMALLOC)
 endif()
 
 #onnxruntime_EXTERNAL_LIBRARIES could contain onnx, onnx_proto,libprotobuf, cuda/cudnn,
 # dnnl/mklml, onnxruntime_codegen_tvm, tvm and pthread
 # pthread is always at the last
-set(onnxruntime_EXTERNAL_LIBRARIES ${onnxruntime_EXTERNAL_LIBRARIES_XNNPACK} WIL::WIL nlohmann_json::nlohmann_json onnx onnx_proto ${PROTOBUF_LIB} re2::re2 Boost::mp11 safeint_interface flatbuffers::flatbuffers ${GSL_TARGET} ${ABSEIL_LIBS} date_interface)
+list(APPEND onnxruntime_EXTERNAL_LIBRARIES xnnpack WIL::WIL nlohmann_json::nlohmann_json onnx onnx_proto ${PROTOBUF_LIB} re2::re2 Boost::headers safeint_interface flatbuffers::flatbuffers ${GSL_TARGET} ${ABSEIL_LIBS} date::date)
 # The source code of onnx_proto is generated, we must build this lib first before starting to compile the other source code that uses ONNX protobuf types.
 # The other libs do not have the problem. All the sources are already there. We can compile them in any order.
-set(onnxruntime_EXTERNAL_DEPENDENCIES onnx_proto flatbuffers::flatbuffers)
-
-target_compile_definitions(onnx PUBLIC $<TARGET_PROPERTY:onnx_proto,INTERFACE_COMPILE_DEFINITIONS> PRIVATE "__ONNX_DISABLE_STATIC_REGISTRATION")
-if (NOT onnxruntime_USE_FULL_PROTOBUF)
-  target_compile_definitions(onnx PUBLIC "__ONNX_NO_DOC_STRINGS")
-endif()
-
-if (onnxruntime_RUN_ONNX_TESTS)
-  add_definitions(-DORT_RUN_EXTERNAL_ONNX_TESTS)
-endif()
-
+list(APPEND onnxruntime_EXTERNAL_DEPENDENCIES onnx_proto flatbuffers::flatbuffers)
 
 if(onnxruntime_ENABLE_ATEN)
   message("Aten fallback is enabled.")
@@ -430,19 +148,10 @@ if(onnxruntime_ENABLE_ATEN)
 endif()
 
 if(onnxruntime_ENABLE_TRAINING OR (onnxruntime_ENABLE_TRAINING_APIS AND onnxruntime_BUILD_UNIT_TESTS))
-  # Once code under orttraining/orttraining/models dir is removed "onnxruntime_ENABLE_TRAINING" should be removed from
-  # this conditional
-  FetchContent_Declare(
-    cxxopts
-    URL ${DEP_URL_cxxopts}
-    URL_HASH SHA1=${DEP_SHA1_cxxopts}
-  )
-  set(CXXOPTS_BUILD_EXAMPLES OFF CACHE BOOL "" FORCE)
-  set(CXXOPTS_BUILD_TESTS OFF CACHE BOOL "" FORCE)
-  onnxruntime_fetchcontent_makeavailable(cxxopts)
+  find_package(cxxopts CONFIG REQUIRED) # cxxopts::cxxopts
 endif()
 
-message("Finished fetching external dependencies")
+message(STATUS "Finished fetching external dependencies")
 
 
 set(onnxruntime_LINK_DIRS )
diff --git a/cmake/CMakeLists.txt b/cmake/CMakeLists.txt
index ee07ec1..553838d 100644
--- a/cmake/CMakeLists.txt
+++ b/cmake/CMakeLists.txt
@@ -755,7 +755,7 @@ endif()
 
 function(onnxruntime_set_compile_flags target_name)
     if (CPUINFO_SUPPORTED)
-      onnxruntime_add_include_to_target(${target_name} cpuinfo)
+      onnxruntime_add_include_to_target(${target_name} cpuinfo::cpuinfo)
     endif()
     if(onnxruntime_ENABLE_EAGER_MODE)
       target_compile_definitions(${target_name} PRIVATE ENABLE_EAGER_MODE)
diff --git a/cmake/external/onnxruntime_external_deps.cmake b/cmake/external/onnxruntime_external_deps.cmake
index 593912e..07d56cd 100644
--- a/cmake/external/onnxruntime_external_deps.cmake
+++ b/cmake/external/onnxruntime_external_deps.cmake
@@ -119,7 +119,8 @@ if (onnxruntime_USE_XNNPACK)
     message(FATAL_ERROR "XNNPACK EP requires the internal NHWC contrib ops to be available "
                          "but onnxruntime_DISABLE_CONTRIB_OPS is ON")
   endif()
-  find_package(xnnpack CONFIG REQUIRED) # xnnpack
+  find_library(XNNPACK_LIBRARY NAMES XNNPACK REQUIRED)
+  find_package(unofficial-pthreadpool CONFIG REQUIRED) # unofficial::pthreadpool unofficial::pthreadpool_interface
 endif()
 
 if (onnxruntime_USE_MIMALLOC)
@@ -130,7 +131,7 @@ endif()
 #onnxruntime_EXTERNAL_LIBRARIES could contain onnx, onnx_proto,libprotobuf, cuda/cudnn,
 # dnnl/mklml, onnxruntime_codegen_tvm, tvm and pthread
 # pthread is always at the last
-list(APPEND onnxruntime_EXTERNAL_LIBRARIES xnnpack WIL::WIL nlohmann_json::nlohmann_json onnx onnx_proto ${PROTOBUF_LIB} re2::re2 Boost::headers safeint_interface flatbuffers::flatbuffers ${GSL_TARGET} ${ABSEIL_LIBS} date::date)
+list(APPEND onnxruntime_EXTERNAL_LIBRARIES ${XNNPACK_LIBRARY} unofficial::pthreadpool WIL::WIL nlohmann_json::nlohmann_json onnx onnx_proto ${PROTOBUF_LIB} re2::re2 Boost::headers safeint_interface flatbuffers::flatbuffers ${GSL_TARGET} ${ABSEIL_LIBS} date::date)
 # The source code of onnx_proto is generated, we must build this lib first before starting to compile the other source code that uses ONNX protobuf types.
 # The other libs do not have the problem. All the sources are already there. We can compile them in any order.
 list(APPEND onnxruntime_EXTERNAL_DEPENDENCIES onnx_proto flatbuffers::flatbuffers)
diff --git a/cmake/onnxruntime_common.cmake b/cmake/onnxruntime_common.cmake
index 0e02ad9..0410d33 100644
--- a/cmake/onnxruntime_common.cmake
+++ b/cmake/onnxruntime_common.cmake
@@ -194,8 +194,8 @@ if (ARM64 OR ARM OR X86 OR X64 OR X86_64)
     # Using it mainly in ARM with Android.
     # Its functionality in detecting x86 cpu features are lacking, so is support for Windows.
     if (CPUINFO_SUPPORTED)
-      onnxruntime_add_include_to_target(onnxruntime_common cpuinfo)
-      list(APPEND onnxruntime_EXTERNAL_LIBRARIES cpuinfo clog)
+      onnxruntime_add_include_to_target(onnxruntime_common cpuinfo::cpuinfo)
+      list(APPEND onnxruntime_EXTERNAL_LIBRARIES cpuinfo::cpuinfo cpuinfo::clog)
     endif()
   endif()
 endif()
diff --git a/cmake/onnxruntime_unittests.cmake b/cmake/onnxruntime_unittests.cmake
index 00c0172..6aeead7 100644
--- a/cmake/onnxruntime_unittests.cmake
+++ b/cmake/onnxruntime_unittests.cmake
@@ -998,7 +998,7 @@ if (NOT onnxruntime_ENABLE_TRAINING_TORCH_INTEROP)
       target_link_libraries(onnxruntime_mlas_benchmark PRIVATE nsync_cpp ${CMAKE_DL_LIBS})
     endif()
     if (CPUINFO_SUPPORTED AND NOT onnxruntime_BUILD_WEBASSEMBLY)
-      target_link_libraries(onnxruntime_mlas_benchmark PRIVATE cpuinfo)
+      target_link_libraries(onnxruntime_mlas_benchmark PRIVATE cpuinfo::cpuinfo)
     endif()
     set_target_properties(onnxruntime_mlas_benchmark PROPERTIES FOLDER "ONNXRuntimeTest")
   endif()
@@ -1276,7 +1276,7 @@ if (NOT onnxruntime_ENABLE_TRAINING_TORCH_INTEROP)
           ${CMAKE_CURRENT_BINARY_DIR})
   target_link_libraries(onnxruntime_mlas_test PRIVATE GTest::gtest GTest::gmock ${ONNXRUNTIME_MLAS_LIBS} onnxruntime_common)
   if (CPUINFO_SUPPORTED AND NOT onnxruntime_BUILD_WEBASSEMBLY)
-    target_link_libraries(onnxruntime_mlas_test PRIVATE cpuinfo)
+    target_link_libraries(onnxruntime_mlas_test PRIVATE cpuinfo::cpuinfo)
   endif()
   if(NOT WIN32)
     target_link_libraries(onnxruntime_mlas_test PRIVATE nsync_cpp ${CMAKE_DL_LIBS})
