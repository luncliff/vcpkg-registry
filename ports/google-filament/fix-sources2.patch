diff --git a/libs/imageio/src/BasisEncoder.cpp b/libs/imageio/src/BasisEncoder.cpp
index 19d7e21..f75faa0 100644
--- a/libs/imageio/src/BasisEncoder.cpp
+++ b/libs/imageio/src/BasisEncoder.cpp
@@ -48,12 +48,12 @@ struct BasisEncoderImpl {
 Builder::Builder(size_t mipCount, size_t layerCount) noexcept : mImpl(new BasisEncoderBuilderImpl) {
     const bool multiple = mImpl->params.m_source_images.size() > 1;
     mImpl->params.m_tex_type = multiple ? basist::cBASISTexType2DArray : basist::cBASISTexType2D;
-    mImpl->params.m_uastc = true;
+    //mImpl->params.m_uastc = true;
     mImpl->params.m_source_images.resize(layerCount);
-    mImpl->params.m_source_mipmap_images.resize(layerCount);
+    //mImpl->params.m_source_mipmap_images.resize(layerCount);
     if (mipCount > 1) {
         for (size_t layer = 0; layer < layerCount; ++layer) {
-            mImpl->params.m_source_mipmap_images[layer].resize(mipCount - 1);
+            //mImpl->params.m_source_mipmap_images[layer].resize(mipCount - 1);
         }
     }
 }
@@ -77,14 +77,15 @@ Builder& Builder::miplevel(size_t level, size_t layer, const LinearImage& floatI
     }
 
     auto& basisBaseLevel = mImpl->params.m_source_images[layer];
-    auto& basisMipmaps = mImpl->params.m_source_mipmap_images[layer];
+    //auto& basisMipmaps = mImpl->params.m_source_mipmap_images[layer];
 
-    if (level >= basisMipmaps.size() + 1) {
-        assert_invariant(false);
-        mImpl->error = true;
-        return *this;
-    }
-    basisu::image* basisImage = level == 0 ? &basisBaseLevel : &basisMipmaps[level - 1];
+    //if (level >= basisMipmaps.size() + 1) {
+    //    assert_invariant(false);
+    //    mImpl->error = true;
+    //    return *this;
+    //}
+    // basisu::image* basisImage = level == 0 ? &basisBaseLevel : &basisMipmaps[level - 1];
+    basisu::image* basisImage = &basisBaseLevel;
 
     LinearImage sourceImage = mImpl->normals ? vectorsToColors(floatImage) : floatImage;
 
@@ -93,15 +94,15 @@ Builder& Builder::miplevel(size_t level, size_t layer, const LinearImage& floatI
     if (mImpl->grayscale) {
         std::unique_ptr<uint8_t[]> data = applyTransferFunction ?
             fromLinearTosRGB<uint8_t, 1>(sourceImage) : fromLinearToGrayscale<uint8_t>(sourceImage);
-        basisImage->init(data.get(), floatImage.getWidth(), floatImage.getHeight(), 1);
+        //basisImage->init(data.get(), floatImage.getWidth(), floatImage.getHeight(), 1);
     } else if (sourceImage.getChannels() == 4) {
         std::unique_ptr<uint8_t[]> data = applyTransferFunction ?
             fromLinearTosRGB<uint8_t, 4>(sourceImage) : fromLinearToRGB<uint8_t, 4>(sourceImage);
-        basisImage->init(data.get(), floatImage.getWidth(), floatImage.getHeight(), 4);
+        //basisImage->init(data.get(), floatImage.getWidth(), floatImage.getHeight(), 4);
     } else if (sourceImage.getChannels() == 3) {
         std::unique_ptr<uint8_t[]> data = applyTransferFunction ?
             fromLinearTosRGB<uint8_t, 3>(sourceImage) : fromLinearToRGB<uint8_t, 3>(sourceImage);
-        basisImage->init(data.get(), floatImage.getWidth(), floatImage.getHeight(), 3);
+        //basisImage->init(data.get(), floatImage.getWidth(), floatImage.getHeight(), 3);
     } else {
         assert_invariant(false);
         mImpl->error = true;
@@ -127,7 +128,7 @@ Builder& Builder::cubemap(bool enabled) noexcept {
 }
 
 Builder& Builder::intermediateFormat(BasisEncoder::IntermediateFormat format) noexcept {
-    mImpl->params.m_uastc = format == IntermediateFormat::UASTC;
+    //mImpl->params.m_uastc = format == IntermediateFormat::UASTC;
     return *this;
 }
 
@@ -160,22 +161,22 @@ BasisEncoder* Builder::build() {
 
     auto& params = mImpl->params;
 
-    params.m_status_output = !mImpl->quiet;
+    //params.m_status_output = !mImpl->quiet;
     params.m_pJob_pool = new basisu::job_pool(mImpl->jobs);
-    params.m_create_ktx2_file = true;
-    params.m_ktx2_uastc_supercompression = basist::KTX2_SS_ZSTANDARD;
+    //params.m_create_ktx2_file = true;
+    //params.m_ktx2_uastc_supercompression = basist::KTX2_SS_ZSTANDARD;
 
     // This sRGB flag doesn't actually affect the compression scheme or the basis format, it's just
     // an annotation that gets stored in the KTX2 file, which enables the app to choose the right
     // format when it loads and transcodes the texture. Technically however, the transcoder
     // SHOULD know about this, since in some scenarios it needs to interpolate between colors.
-    params.m_ktx2_srgb_transfer_func = !mImpl->linear;
+    //params.m_ktx2_srgb_transfer_func = !mImpl->linear;
 
     // Select the same quality that the basis tool selects by default (midpoint of range).
     params.m_quality_level = 128;
 
     // This is the default zstd compression level used by the basisu cmdline cool.
-    params.m_ktx2_zstd_supercompression_level = 6;
+    //params.m_ktx2_zstd_supercompression_level = 6;
 
     // We do not want basis to read from files, we want it to read from "m_source_images"
     params.m_read_source_images = false;
@@ -204,7 +205,7 @@ BasisEncoder::~BasisEncoder() noexcept {
     delete mImpl->encoder;
     delete mImpl->jobs;
     delete mImpl;
-    basisu::basisu_encoder_deinit();
+    //basisu::basisu_encoder_deinit();
 }
 
 BasisEncoder::BasisEncoder(BasisEncoder&& that) noexcept  : mImpl(nullptr) {
@@ -232,9 +233,9 @@ bool BasisEncoder::encode() {
     case basis_compressor::cECFailedValidating:
         puts("Compressor failed 2darray/cubemap/video validation checks!");
         break;
-    case basis_compressor::cECFailedEncodeUASTC:
-        puts("Compressor UASTC encode failed!");
-        break;
+    //case basis_compressor::cECFailedEncodeUASTC:
+    //    puts("Compressor UASTC encode failed!");
+    //    break;
     case basis_compressor::cECFailedFrontEnd:
         puts("Compressor frontend stage failed!");
         break;
@@ -250,12 +251,12 @@ bool BasisEncoder::encode() {
     case basis_compressor::cECFailedWritingOutput:
         puts("Compressor failed writing to output Basis file!");
         break;
-    case basis_compressor::cECFailedUASTCRDOPostProcess:
-        puts("Compressor failed during the UASTC post process step!");
-        break;
-    case basis_compressor::cECFailedCreateKTX2File:
-        puts("Compressor failed creating KTX2 file data!");
-        break;
+    //case basis_compressor::cECFailedUASTCRDOPostProcess:
+    //    puts("Compressor failed during the UASTC post process step!");
+    //    break;
+    //case basis_compressor::cECFailedCreateKTX2File:
+    //    puts("Compressor failed creating KTX2 file data!");
+    //    break;
     default:
         puts("basis_compress::process() failed!");
         break;
@@ -264,11 +265,11 @@ bool BasisEncoder::encode() {
 }
 
 size_t BasisEncoder::getKtx2ByteCount() const noexcept {
-    return mImpl->encoder->get_output_ktx2_file().size();
+    return mImpl->encoder->get_output_basis_file().size();
 }
 
 uint8_t const* BasisEncoder::getKtx2Data() const noexcept {
-    return mImpl->encoder->get_output_ktx2_file().data();
+    return mImpl->encoder->get_output_basis_file().data();
 }
 
 } // namespace image
diff --git a/libs/ktxreader/src/Ktx2Reader.cpp b/libs/ktxreader/src/Ktx2Reader.cpp
index d401133..a808fd8 100644
--- a/libs/ktxreader/src/Ktx2Reader.cpp
+++ b/libs/ktxreader/src/Ktx2Reader.cpp
@@ -88,8 +88,8 @@ static FinalFormatInfo getFinalFormatInfo(Texture::InternalFormat fmt) {
         case tif::DXT5_RGBA: return {"DXT5_RGBA", true, true, LINEAR, ttf::cTFBC3_RGBA, tct::DXT5_SRGBA};
         case tif::RED_RGTC1: return {"RED_RGTC1", true, true, LINEAR, ttf::cTFBC4_R, tct::RED_RGTC1};
         case tif::RED_GREEN_RGTC2: return {"RED_GREEN_RGTC2", true, true, LINEAR, ttf::cTFBC5_RG, tct::RED_GREEN_RGTC2};
-        case tif::RGBA_BPTC_UNORM: return {"RGBA_BPTC_UNORM", true, true, LINEAR, ttf::cTFBC7_RGBA, tct::RGBA_BPTC_UNORM};
-        case tif::SRGB_ALPHA_BPTC_UNORM: return {"SRGB_ALPHA_BPTC_UNORM", true, true, sRGB, ttf::cTFBC7_RGBA, tct::SRGB_ALPHA_BPTC_UNORM};
+        //case tif::RGBA_BPTC_UNORM: return {"RGBA_BPTC_UNORM", true, true, LINEAR, ttf::cTFBC7_RGBA, tct::RGBA_BPTC_UNORM};
+        //case tif::SRGB_ALPHA_BPTC_UNORM: return {"SRGB_ALPHA_BPTC_UNORM", true, true, sRGB, ttf::cTFBC7_RGBA, tct::SRGB_ALPHA_BPTC_UNORM};
         case tif::SRGB8_ALPHA8_ASTC_4x4: return {"SRGB8_ALPHA8_ASTC_4x4", true, true, sRGB, ttf::cTFASTC_4x4_RGBA, tct::RGBA_ASTC_4x4};
         case tif::RGBA_ASTC_4x4: return {"RGBA_ASTC_4x4", true, true, LINEAR, ttf::cTFASTC_4x4_RGBA, tct::SRGB8_ALPHA8_ASTC_4x4};
         case tif::EAC_R11: return {"EAC_R11", true, true, LINEAR, ttf::cTFETC2_EAC_R11, tct::EAC_R11};
diff --git a/libs/viewer/src/RemoteServer.cpp b/libs/viewer/src/RemoteServer.cpp
index 441c730..89c492f 100644
--- a/libs/viewer/src/RemoteServer.cpp
+++ b/libs/viewer/src/RemoteServer.cpp
@@ -208,8 +208,8 @@ bool MessageReceiver::handleData(CivetServer* server, struct mg_connection* conn
 
 void MessageSender::sendMessage(const char* label, const char* buffer, size_t bufsize) {
     for (auto iter : connections) {
-        mg_websocket_write(iter.first, 0x80, label, strlen(label) + 1);
-        mg_websocket_write(iter.first, 0x80, buffer, bufsize);
+        mg_websocket_write(const_cast<mg_connection*>(iter.first), 0x80, label, strlen(label) + 1);
+        mg_websocket_write(const_cast<mg_connection*>(iter.first), 0x80, buffer, bufsize);
     }
 }
 
